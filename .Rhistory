# Load table and calculate cutoff
count.cutoff <- quantile(count.sorted.table$Count, probs = percentile)
count.true.cut <- floor(count.cutoff/10)
# Name of the file
bnm <- basename(output.count.file)
bnm.parts <- strsplit(bnm, "[.]")[[1]]
bnm.only <- paste(bnm.parts[1:(length(bnm.parts) - 1)], collapse = "_")
# Plot
plot(count.sorted.table$Count, main="CellTag Whitelist",xlab="CellTag",ylab="Reads")
abline(v=sum(count.sorted.table$Count >= count.true.cut), col="red", lty=2)
print(paste0("Abline Threshold: ", sum(count.sorted.table$Count >= count.true.cut)))
# Subset the ones pass filtering
whitelist <- subset(count.sorted.table, Count>=count.true.cut)
if (save.whitelist) {
if (is.null(output.dir)) {
output.dir <- paste0(dirname(celltag.obj@fastq.bam.dir), celltag.obj@celltag.version, "_whitelist.csv")
} else {
write.csv(whitelist, output.dir, quote = F, row.names = F)
}
}
celltag.obj@whitelist <- whitelist
return(celltag.obj)
}
#' Fastq Process Function
#'
#' This function extracts CellTags from the raw fastq sequencing file, provides counts of each CellTag and sorts them in desending order.
#' @param fastq.file The input fastq/bam data directory
#' @param pattern The pattern to seek for
#' @param short.nt.before.tag A short sequence before the 8nt tag to help more specific identification
#' @param short.nt.after.tag A short sequence after the 8nt tag to help more specific identification
#' @return A list contains count table of CellTags. If requested to save fullTag counts, i.e. save.fullTag.counts = TRUE, return a list of both 8nt tags and full sequences count. Otherwise, a list of 8nt tags counts.
#' @keywords single-cell RNA-seq data, CellTagging
#' @export
#' @examples
#' fastq.process("data.fastq", "CCGGT[ATCG]{8}GAATTC", "CCGGT", "GAATTC")
#'
fastq.process <- function(fastq.file, pattern, short.nt.before.tag, short.nt.after.tag) {
con <- file(fastq.file, "r")
# Get the sequences containing the tags (with both full tag region and only 8nt tag)
seq.list <- c()
filtered.sequences <- c()
full.tag.seq <- c()
only.tag.seq <- c()
print("Reading File......")
while(TRUE) {
curr.lines <- readLines(con, 1000000)
if (length(curr.lines) == 0) break
else {
curr.seqs <- curr.lines[seq(2, 1000000, by = 4)]
seq.list <- c(seq.list, curr.seqs)
reg.rslt <- regexpr(pattern, curr.seqs, ignore.case = TRUE, perl = TRUE)
contain.idx <- which(reg.rslt > 0)
curr.f.seq <- curr.seqs[contain.idx]
filtered.sequences <- c(filtered.sequences, curr.f.seq)
start.loc <- reg.rslt[contain.idx]
end.loc <- start.loc + nchar(short.nt.before.tag) + 8 + nchar(short.nt.after.tag) - 1
curr.full.tag <- substr(curr.f.seq, start = start.loc, stop = end.loc)
only.tag <- substr(curr.full.tag, start = (nchar(short.nt.before.tag) + 1), stop = (nchar(short.nt.before.tag) + 8))
full.tag.seq <- c(full.tag.seq, curr.full.tag)
only.tag.seq <- c(only.tag.seq, only.tag)
}
}
close(con)
rslt <- list(full.tag.seq, only.tag.seq)
return(rslt)
}
#' Bam File Process Function
#'
#' This function extracts CellTags from the bam sequencing file, provides cell barcode, umi and their corresponding celltag information.
#' @param bam.file The input bam data directory
#' @param pattern The pattern to seek for
#' @param short.nt.before.tag A short sequence before the 8nt tag to help more specific identification
#' @param short.nt.after.tag A short sequence after the 8nt tag to help more specific identification
#' @return A data table contains cell barcode, celltag and umi information
#' @keywords single-cell RNA-seq data, CellTagging
#' @export
#' @examples
#' bam.process("data.fastq", "CCGGT[ATCG]{8}GAATTC", "CCGGT", "GAATTC")
#'
bam.process <- function(bam.file, pattern, short.nt.before.tag, short.nt.after.tag) {
# Install Rsamtools
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
if (!requireNamespace("Rsamtools", quietly = TRUE)) {
BiocManager::install("Rsamtools", version = "3.8")
}
library(Rsamtools)
# Get the bam file
bamFile <- BamFile(bam.file)
yieldSize(bamFile) <- 1000000
open(bamFile)
parameters <- ScanBamParam(what = scanBamWhat(), tag = c("CB", "GN", "UB", "CR"))
bam.parsed.df <- data.table()
count <- 0
while(TRUE) {
curr.read <- scanBam(bamFile, param = parameters)[[1]]
print(count)
if (length(curr.read$qname) <= 0) {
break
} else {
# Read in all information
curr.seqs <- as.character(curr.read$seq)
# Check if the sequences contain the celltag motif
reg.rslt <- regexpr(pattern, curr.seqs, ignore.case = TRUE, perl = TRUE)
contain.idx <- which(reg.rslt > 0)
if (length(contain.idx) > 0) {
curr.cell.bc <- curr.read$tag$CB
curr.umi <- curr.read$tag$UB
curr.cell.tag <- rep(NA, length(curr.read$qname))
if (!(is.null(curr.cell.bc) | is.null(curr.umi))) {
# Initialize the current data table
curr.df <- data.table(Cell.BC = curr.cell.bc, UMI = curr.umi, Cell.Tag = curr.cell.tag)
curr.f.seq <- curr.seqs[contain.idx]
start.loc <- reg.rslt[contain.idx]
end.loc <- start.loc + nchar(short.nt.before.tag) + 8 + nchar(short.nt.after.tag) - 1
curr.full.tag <- substr(curr.f.seq, start = start.loc, stop = end.loc)
only.tag <- substr(curr.full.tag, start = (nchar(short.nt.before.tag) + 1), stop = (nchar(short.nt.before.tag) + 8))
curr.df$Cell.Tag[contain.idx] <- only.tag
# Add to the current data frame
if (nrow(bam.parsed.df) <= 0) {
bam.parsed.df <- curr.df[contain.idx,]
} else {
bam.parsed.df <- rbind(bam.parsed.df, curr.df[contain.idx, ])
}
}
}
}
count <- count + 1
}
close(bamFile)
return(bam.parsed.df)
}
CellTagMatrixCount <- function(celltag.obj, barcodes.file) {
# Read in the cell barcodes identified during alignment
barcodeList <- fread(barcodes.file, header = FALSE)[[1]]
celltagData <- celltag.obj@bam.parse.rslt
#With the parsed CellTag reads loaded we can then easily filter the data and generate UMI Counts for each Cell Barcode/Cell Tag combination.
#-Groups the data.table by Cell Barcode/Cell Tag combination and creates a new column "UMI.Count" which has the number of unique UMI associated with each Cell Barcode/Cell.Tag combination. uniqueN is equivalent to length(unique(UMI))
celltagCounts <- celltagData[, .(UMI.Count = uniqueN(UMI)), .(Cell.BC, Cell.Tag)]
#The data is now in a long format and needs to be reshaped. We will cast the long data into a wide format resembling a matrix.
celltagCountsWide <- dcast(data = celltagCounts, formula = Cell.BC ~ Cell.Tag, value.var = "UMI.Count", fill = 0 )
#Now we have the data we want in the correct format. Next we can add Cells from the barcode list that were not in the celltagData.
missingCells <- barcodeList[!(barcodeList %in% celltagCountsWide$Cell.BC)]
#Lets make a data.table with one column Cell.BC which will contain a list of the missing cells. This can then be merged with the UMI Count data table.
missingCells <- data.table(Cell.BC = missingCells)
#Bind the missing cells to the data.table containing the Cell Tag UMI Counts.
alltagCounts <- rbind(celltagCountsWide, missingCells, fill = TRUE)
#We have added the missing cells, whose values now need to be changed from NA to 0.
alltagCounts[is.na(alltagCounts)] <- 0
#Now we can filter out cells which are not in our barcode list.
alltagCounts <- alltagCounts[Cell.BC %in% barcodeList, ]
#Generate dgCMatrix
dgc.mtx <- as.matrix(alltagCounts[, c(2:ncol(alltagCounts))])
rownames(dgc.mtx) <- alltagCounts$Cell.BC
#Lets also filter Cell Tags in which no UMIs are counted.
celltagExpr <- colSums(alltagCounts[, -1])
tagsRemove <- names(celltagExpr)[celltagExpr == 0]
alltagCounts[, (tagsRemove):= NULL]
#We now have a final matrix. Next lets generate some stats about the Cell Tags.
celltagExpr <- summary(colSums(alltagCounts[, -1]))
cellsPerTag <- summary(colSums(alltagCounts[, -1] > 0))
cellExpr <- summary(rowSums(alltagCounts[, -1]))
tagsPerCell <- rowSums(alltagCounts[, -1] > 0)
tagsPerCellSum <- summary(tagsPerCell)
stats.df <- rbind(celltagExpr, cellsPerTag, cellExpr, tagsPerCellSum)
rownames(stats.df) <- c("CellTag.UMI.Counts", "Cells.per.CellTag", "Cell.UMI.Counts", "CellTags.per.Cell")
stats.df <- as.data.frame(stats.df)
celltag.obj@celltag.stats <- stats.df
celltag.obj@raw.count <- as(dgc.mtx, "dgCMatrix")
return(celltag.obj)
}
test.obj <- AddCellTagFreqSort(test.obj)
CellTagObject <- function(object.name, fastq.bam.input, celltag.version) {
setClass("CellTag",
slots = list(obj.name = "character",
fastq.bam.dir = "character",
celltag.version = "character",
fastq.full.celltag = "ANY",
fastq.only.celltag = "ANY",
celltag.freq.stats = "data.table",
whitelist = "data.frame",
bam.parse.rslt = "ANY",
celltag.stats = "data.frame",
raw.count = "dgCMatrix",
whitelisted.count = "dgCMatrix",
metric.filtered.count = "dgCMatrix",
binary.mtx = "dgCMatrix",
jaccard.mtx = "dgCMatrix",
clone.composition = "matrix",
clone.size.info = "data.frame"))
setMethod("show",
"CellTag",
function(object) {
cat("Object name: ", object@obj.name, "\n")
cat("Raw CellTag Counts = ", (ncol(object@raw.count)), "\n")
cat("Raw Number of Cells with CellTag = ", nrow(object@raw.count), "\n")
cat("Whitelisted CellTag Counts = ", (ncol(object@whitelisted.count)), "\n")
cat("Whitelisted Number of Cells with CellTag = ", nrow(object@whitelisted.count), "\n")
})
#
# setMethod("CellTagExtraction",
#           "CellTag",
#           function(celltag.obj) {
#             CellTagExtraction(celltag.obj)
#           })
#
# setMethod("CellTagMatrixCount",
#           "CellTag",
#           function(celltag.obj, barcodes.file) {
#             CellTagMatrixCount(celltag.obj, barcodes.file)
#           })
#
# setMethod("SingleCellDataBinatization",
#           "CellTag",
#           function(celltag.obj, tag.cutoff) {
#             SingleCellDataBinatization(celltag.obj, tag.cutoff)
#           })
#
# setMethod("SingleCellDataWhitelist",
#           "CellTag",
#           function(celltag.obj, whitels.cell.tag.file) {
#             SingleCellDataWhitelist(celltag.obj, whitels.cell.tag.file)
#           })
#
# # setMethod("MetricPlots",
# #           "CellTag",
# #           function(object) {
# #             celltag.data <- object@whitelisted.count
# #             CellTags.per.cell.whitelisted.pf <- rowSums(celltag.data)
# #             CellTags.per.cell.avg <- mean(CellTags.per.cell.whitelisted.pf)
# #             CellTags.frequency.whitelisted.pf <- colSums(celltag.data)
# #             CellTags.freq.avg <- mean(CellTags.frequency.whitelisted.pf)
# #             plot(CellTags.per.cell.whitelisted.pf)
# #             plot(CellTags.frequency.whitelisted.pf)
# #             cat("Average: ", CellTags.per.cell.whitelisted.pf, "\n")
# #             cat("Frequency: ", CellTags.frequency.whitelisted.pf, "\n")
# #           })
#
# setMethod("MetricBasedFiltering",
#           "CellTag",
#           function(celltag.obj, cutoff, comparison = "less") {
#             filtered.mtx <- MetricBasedFiltering(celltag.obj, cutoff, comparison)
#             celltag.obj@metric.filtered.count <- filtered.mtx
#             celltag.obj
#           })
#
# setMethod("JaccardAnalysis",
#           "CellTag",
#           function(celltag.obj, plot.corr = TRUE) {
#             mtx <- JaccardAnalysis(celltag.obj, plot.corr)
#             celltag.obj@jaccard.mtx <- as(mtx, dgCMatrix)
#             celltag.obj
#           })
#
# setMethod("CloneCalling",
#           "CellTag",
#           function(celltag.obj, correlation.cutoff) {
#             rslts <- CloneCalling(celltag.obj, correlation.cutoff)
#             celltag.obj@clone.composition <- rslts[[1]]
#             celltag.obj@clone.size.info <- rslts[[2]]
#             celltag.obj
#           })
ct <- new("CellTag", obj.name = object.name, fastq.bam.dir = fastq.bam.input, celltag.version = celltag.version)
return(ct)
}
test.obj <- CellTagObject("test_object", fastq.bam.input = "~/Desktop/CellTaggeR test/V2-1_S2_L001_R1_001.fastq", celltag.version = "v2")
CellTagObject <- function(object.name, fastq.bam.input, celltag.version) {
setClass("CellTag",
slots = list(obj.name = "character",
fastq.bam.dir = "character",
celltag.version = "character",
fastq.full.celltag = "ANY",
fastq.only.celltag = "ANY",
celltag.freq.stats = "ANY",
whitelist = "data.frame",
bam.parse.rslt = "ANY",
celltag.stats = "data.frame",
raw.count = "dgCMatrix",
whitelisted.count = "dgCMatrix",
metric.filtered.count = "dgCMatrix",
binary.mtx = "dgCMatrix",
jaccard.mtx = "dgCMatrix",
clone.composition = "matrix",
clone.size.info = "data.frame"))
setMethod("show",
"CellTag",
function(object) {
cat("Object name: ", object@obj.name, "\n")
cat("Raw CellTag Counts = ", (ncol(object@raw.count)), "\n")
cat("Raw Number of Cells with CellTag = ", nrow(object@raw.count), "\n")
cat("Whitelisted CellTag Counts = ", (ncol(object@whitelisted.count)), "\n")
cat("Whitelisted Number of Cells with CellTag = ", nrow(object@whitelisted.count), "\n")
})
#
# setMethod("CellTagExtraction",
#           "CellTag",
#           function(celltag.obj) {
#             CellTagExtraction(celltag.obj)
#           })
#
# setMethod("CellTagMatrixCount",
#           "CellTag",
#           function(celltag.obj, barcodes.file) {
#             CellTagMatrixCount(celltag.obj, barcodes.file)
#           })
#
# setMethod("SingleCellDataBinatization",
#           "CellTag",
#           function(celltag.obj, tag.cutoff) {
#             SingleCellDataBinatization(celltag.obj, tag.cutoff)
#           })
#
# setMethod("SingleCellDataWhitelist",
#           "CellTag",
#           function(celltag.obj, whitels.cell.tag.file) {
#             SingleCellDataWhitelist(celltag.obj, whitels.cell.tag.file)
#           })
#
# # setMethod("MetricPlots",
# #           "CellTag",
# #           function(object) {
# #             celltag.data <- object@whitelisted.count
# #             CellTags.per.cell.whitelisted.pf <- rowSums(celltag.data)
# #             CellTags.per.cell.avg <- mean(CellTags.per.cell.whitelisted.pf)
# #             CellTags.frequency.whitelisted.pf <- colSums(celltag.data)
# #             CellTags.freq.avg <- mean(CellTags.frequency.whitelisted.pf)
# #             plot(CellTags.per.cell.whitelisted.pf)
# #             plot(CellTags.frequency.whitelisted.pf)
# #             cat("Average: ", CellTags.per.cell.whitelisted.pf, "\n")
# #             cat("Frequency: ", CellTags.frequency.whitelisted.pf, "\n")
# #           })
#
# setMethod("MetricBasedFiltering",
#           "CellTag",
#           function(celltag.obj, cutoff, comparison = "less") {
#             filtered.mtx <- MetricBasedFiltering(celltag.obj, cutoff, comparison)
#             celltag.obj@metric.filtered.count <- filtered.mtx
#             celltag.obj
#           })
#
# setMethod("JaccardAnalysis",
#           "CellTag",
#           function(celltag.obj, plot.corr = TRUE) {
#             mtx <- JaccardAnalysis(celltag.obj, plot.corr)
#             celltag.obj@jaccard.mtx <- as(mtx, dgCMatrix)
#             celltag.obj
#           })
#
# setMethod("CloneCalling",
#           "CellTag",
#           function(celltag.obj, correlation.cutoff) {
#             rslts <- CloneCalling(celltag.obj, correlation.cutoff)
#             celltag.obj@clone.composition <- rslts[[1]]
#             celltag.obj@clone.size.info <- rslts[[2]]
#             celltag.obj
#           })
ct <- new("CellTag", obj.name = object.name, fastq.bam.dir = fastq.bam.input, celltag.version = celltag.version)
return(ct)
}
test.obj <- CellTagObject("test_object", fastq.bam.input = "~/Desktop/CellTaggeR test/V2-1_S2_L001_R1_001.fastq", celltag.version = "v2")
test.obj <- CellTagExtraction(test.obj)
test.obj <- AddCellTagFreqSort(test.obj)
test.obj <- CellTagWhitelistFiltering(test.obj, 0.9)
#' @param percentile A fraction cutoff percentile for filtering the CellTags e.g. 0.9 for 90th percentile
#' @param output.dir Which directory would you like to store these files?
#' @param output.count.file Which CSV filename would you like to save to for the filtered count table? Default to NULL. If NULL but save.output = TRUE, automatic names will be generated and used for storage
#' @param save.output Would you like to save your whitelisted counts to file? Default to TRUE
#' @return Whitelisted CellTag count table
#' @keywords single-cell RNA-seq data, CellTagging
#' @export
#' @examples
#' CellTagWhitelistFiltering("data.txt", 0.9, "~/Desktop/", "My_Favourite_Whitelist.csv")
#'
CellTagWhitelistFiltering <- function(celltag.obj, percentile, output.dir = NULL, save.whitelist = TRUE) {
count.sorted.table <- celltag.obj@celltag.freq.stats
# Load table and calculate cutoff
count.cutoff <- quantile(count.sorted.table$Count, probs = percentile)
count.true.cut <- floor(count.cutoff/10)
# Plot
plot(count.sorted.table$Count, main="CellTag Whitelist",xlab="CellTag",ylab="Reads")
abline(v=sum(count.sorted.table$Count >= count.true.cut), col="red", lty=2)
print(paste0("Abline Threshold: ", sum(count.sorted.table$Count >= count.true.cut)))
# Subset the ones pass filtering
whitelist <- subset(count.sorted.table, Count>=count.true.cut)
if (save.whitelist) {
if (is.null(output.dir)) {
output.dir <- paste0(dirname(celltag.obj@fastq.bam.dir), celltag.obj@celltag.version, "_whitelist.csv")
} else {
write.csv(whitelist, output.dir, quote = F, row.names = F)
}
}
celltag.obj@whitelist <- whitelist
return(celltag.obj)
}
test.obj <- CellTagWhitelistFiltering(test.obj, 0.9)
dirname(test.obj@fastq.bam.dir)
#' @param percentile A fraction cutoff percentile for filtering the CellTags e.g. 0.9 for 90th percentile
#' @param output.dir Which directory would you like to store these files?
#' @param output.count.file Which CSV filename would you like to save to for the filtered count table? Default to NULL. If NULL but save.output = TRUE, automatic names will be generated and used for storage
#' @param save.output Would you like to save your whitelisted counts to file? Default to TRUE
#' @return Whitelisted CellTag count table
#' @keywords single-cell RNA-seq data, CellTagging
#' @export
#' @examples
#' CellTagWhitelistFiltering("data.txt", 0.9, "~/Desktop/", "My_Favourite_Whitelist.csv")
#'
CellTagWhitelistFiltering <- function(celltag.obj, percentile, output.dir = NULL, save.whitelist = TRUE) {
count.sorted.table <- celltag.obj@celltag.freq.stats
# Load table and calculate cutoff
count.cutoff <- quantile(count.sorted.table$Count, probs = percentile)
count.true.cut <- floor(count.cutoff/10)
# Plot
plot(count.sorted.table$Count, main="CellTag Whitelist",xlab="CellTag",ylab="Reads")
abline(v=sum(count.sorted.table$Count >= count.true.cut), col="red", lty=2)
print(paste0("Abline Threshold: ", sum(count.sorted.table$Count >= count.true.cut)))
# Subset the ones pass filtering
whitelist <- subset(count.sorted.table, Count>=count.true.cut)
if (save.whitelist) {
if (is.null(output.dir)) output.dir <- paste0(dirname(celltag.obj@fastq.bam.dir), celltag.obj@celltag.version, "_whitelist.csv")
write.csv(whitelist, output.dir, quote = F, row.names = F)
}
celltag.obj@whitelist <- whitelist
return(celltag.obj)
}
#' @param percentile A fraction cutoff percentile for filtering the CellTags e.g. 0.9 for 90th percentile
#' @param output.dir Which directory would you like to store these files?
#' @param output.count.file Which CSV filename would you like to save to for the filtered count table? Default to NULL. If NULL but save.output = TRUE, automatic names will be generated and used for storage
#' @param save.output Would you like to save your whitelisted counts to file? Default to TRUE
#' @return Whitelisted CellTag count table
#' @keywords single-cell RNA-seq data, CellTagging
#' @export
#' @examples
#' CellTagWhitelistFiltering("data.txt", 0.9, "~/Desktop/", "My_Favourite_Whitelist.csv")
#'
CellTagWhitelistFiltering <- function(celltag.obj, percentile, output.dir = NULL, save.whitelist = TRUE) {
count.sorted.table <- celltag.obj@celltag.freq.stats
# Load table and calculate cutoff
count.cutoff <- quantile(count.sorted.table$Count, probs = percentile)
count.true.cut <- floor(count.cutoff/10)
# Plot
plot(count.sorted.table$Count, main="CellTag Whitelist",xlab="CellTag",ylab="Reads")
abline(v=sum(count.sorted.table$Count >= count.true.cut), col="red", lty=2)
print(paste0("Abline Threshold: ", sum(count.sorted.table$Count >= count.true.cut)))
# Subset the ones pass filtering
whitelist <- subset(count.sorted.table, Count>=count.true.cut)
if (save.whitelist) {
if (is.null(output.dir)) output.dir <- paste0(dirname(celltag.obj@fastq.bam.dir), "/", celltag.obj@celltag.version, "_whitelist.csv")
write.csv(whitelist, output.dir, quote = F, row.names = F)
}
celltag.obj@whitelist <- whitelist
return(celltag.obj)
}
test.obj <- CellTagWhitelistFiltering(test.obj, 0.9)
#' @param percentile A fraction cutoff percentile for filtering the CellTags e.g. 0.9 for 90th percentile
#' @param output.dir Which directory would you like to store these files?
#' @param output.count.file Which CSV filename would you like to save to for the filtered count table? Default to NULL. If NULL but save.output = TRUE, automatic names will be generated and used for storage
#' @param save.output Would you like to save your whitelisted counts to file? Default to TRUE
#' @return Whitelisted CellTag count table
#' @keywords single-cell RNA-seq data, CellTagging
#' @export
#' @examples
#' CellTagWhitelistFiltering("data.txt", 0.9, "~/Desktop/", "My_Favourite_Whitelist.csv")
#'
CellTagWhitelistFiltering <- function(celltag.obj, percentile, output.dir = NULL) {
# Load table and calculate cutoff
count.sorted.table <- celltag.obj@celltag.freq.stats
count.cutoff <- quantile(count.sorted.table$Count, probs = percentile)
count.true.cut <- floor(count.cutoff/10)
# Plot
plot(count.sorted.table$Count, main="CellTag Whitelist",xlab="CellTag",ylab="Reads")
abline(v=sum(count.sorted.table$Count >= count.true.cut), col="red", lty=2)
cat(paste0("Abline Threshold: ", sum(count.sorted.table$Count >= count.true.cut)), "\n")
# Subset the ones pass filtering
whitelist <- subset(count.sorted.table, Count>=count.true.cut)
if (is.null(output.dir)) output.dir <- paste0(dirname(celltag.obj@fastq.bam.dir), "/", celltag.obj@celltag.version, "_whitelist.csv")
write.csv(whitelist, output.dir, quote = F, row.names = F)
cat("File is saved: ", output.dir, "\n")
celltag.obj@whitelist <- whitelist
return(celltag.obj)
}
test.obj <- CellTagWhitelistFiltering(test.obj, 0.9)
bam.test.chr18.obj <- CellTagObject("test_bam_chr18_object", fastq.bam.input = "~/Desktop/CellTaggeR test/hf1_d15_chr18.bam", celltag.version = "v1")
bam.test.chr18.obj <- CellTagExtraction(bam.test.chr18.obj)
bam.test.chr1.obj <- CellTagObject("test_bam_chr1_object", fastq.bam.input = "~/Desktop/CellTaggeR test/hf1.d15.possorted_genome_bam.REF_1.bam", celltag.version = "v1")
bam.test.chr1.obj <- CellTagExtraction(bam.test.chr1.obj)
library(CloneHunter)
library(roxygen2)
library(devtools)
setwd("~/Desktop/Morris Lab/CloneHunterNew/")
devtools::document()
CellTagObject("test", "~/Desktop/CellTaggeR test/V2-1_S2_L001_R1_001.fastq", "v1")
devtools::document()
CellTagObject("test", "~/Desktop/CellTaggeR test/V2-1_S2_L001_R1_001.fastq", "v1")
CellTagClassSet()
class()
class
isClass("CellTag")
CellTagObject("test", "~/Desktop/CellTaggeR test/V2-1_S2_L001_R1_001.fastq", "v1")
devtools::document()
CellTagObject("test", "~/Desktop/CellTaggeR test/V2-1_S2_L001_R1_001.fastq", "v1")
devtools::document()
CellTagObject("test", "~/Desktop/CellTaggeR test/V2-1_S2_L001_R1_001.fastq", "v1")
new("CellTag")
new("CellTag", "test", "~/Desktop/CellTaggeR test/V2-1_S2_L001_R1_001.fastq", "v1")
new("CellTag", object.name = "test", "~/Desktop/CellTaggeR test/V2-1_S2_L001_R1_001.fastq", "v1")
new("CellTag", object.name = "test")
new("CellTag", obj.name = "test")
devtools::document()
new("CellTag", obj.name = "test")
devtools::document()
new("CellTag", object.name = "test", "~/Desktop/CellTaggeR test/V2-1_S2_L001_R1_001.fastq", "v1")
new("CellTag", obj.name = "test", fastq.bam.dir = "~/Desktop/CellTaggeR test/V2-1_S2_L001_R1_001.fastq", celltag.version = "v1")
